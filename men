#!/usr/bin/env node
'use strict'

const nodeSetup = require('./node-setup')
const utils = require('./utils')
const renderer = require('./template-renderer')
const names = require('./names')
const template = require('./template')
const to = require('./to')
const yargs = require('./yargs')

const exec = require('child_process').exec
const fs = require('fs')
const opn = require('opn')

const nameList = names.getList()

// yargs params stuff:

const argv = yargs.init()

if ((argv.run === false || argv.n) && (argv.open || argv.o)) {
  utils.logYellow(`WARN: --open can't be used if --no-run is present`, true)
}

let projectFolderName = argv._[0]// this is the only required command
let defaultModelName = 'MyItem'
let entitiesToCreate = []

if (argv.entities || argv.e) {
  entitiesToCreate = (argv.entities || argv.e).split(',')

  let invalidNames = entitiesToCreate.filter(item => utils.invalidName(item))
  let invalid = invalidNames.length ? invalidNames.toString() : null
  if (invalid) {
    utils.logRed(`Invalid names: ${invalid}`, true)
    utils.logYellow('Entity names must match [a-zA-Z_][0-9a-zA-Z_]*$', true)
    return
  }


  entitiesToCreate = entitiesToCreate.map(item => {
    return utils.cap(item.trim())// capitalize entity names
  })
} else {
  entitiesToCreate = [ defaultModelName ]
}

let port = (argv.port || argv.p) || 5501

// get database name:

let dbName = (argv.database || argv.d) || projectFolderName + '_DB'

// templates:

let tmplts = template.getList(`${__dirname}/${nameList.templatesFolder}`)

// the real deal:

let generateImportedRoutes = () => {
  return entitiesToCreate.map(item => {
    return renderer.renderTemplate(tmplts.importedRoutesLine, [{
      pattern: nameList.targetImportedRoutes,
      value: item }])
  }).join('\n')
}

let generateConnectedRoutes = () => {
  return entitiesToCreate.map(item => {
    return renderer.renderTemplate(tmplts.apiConnectedRoutesLine, [{
      pattern: nameList.targetAPIConnectedRoutes,
      value: item }])
  }).join('\n')
}

let renderAppTemplate = (entityRouteLines, apiConnectedRoutes) => {
  return renderer.renderTemplate(tmplts.appTemplate, [{
    pattern: nameList.targetImportedRoutesList,
    value: entityRouteLines
  }, {
    pattern: nameList.targetAPIConnectedRoutesList,
    value: apiConnectedRoutes
  }, {
    pattern: nameList.targetEntitiesList,
    value: entitiesToCreate.map(item => `'${item}'`).join(',')
  }])
}

let makeAppFile = () => {
  let entityRouteLines = generateImportedRoutes()
  let apiConnectedRoutes = generateConnectedRoutes()

  return new Promise((resolve, reject) => {
    let renderApp = renderAppTemplate(entityRouteLines, apiConnectedRoutes)

    fs.writeFile(`./app.js`, renderApp, err => {
      if (err) {
        reject(err)
        return
      }

      utils.logMagenta('--> Created app.js', true)
      resolve(utils.OK_CODE)
    })
  })
}

let makeDbFile = () => {
  return new Promise((resolve, reject) => {
    fs.writeFile(`./db.js`, renderer.renderTemplate(tmplts.dbTemplate, [{
      pattern: nameList.targetDBName,
      value: dbName
    }]), err => {
      if (err) {
        reject(err)
        return
      }

      utils.logMagenta('--> Created db.js', true)
      resolve(utils.OK_CODE)
    })
  })
}

let makeIndexFile = () => {
  return new Promise((resolve, reject) => {
    fs.writeFile(`./index.js`, renderer.renderTemplate(tmplts.indexTemplate, [{
      pattern: nameList.targetNodePort,
      value: port
    }]), err => {
      if (err) {
        reject(err)
        return
      }

      utils.logMagenta('--> Created index.js', true)
      resolve(utils.OK_CODE)
    })
  })
}

let generateController = (modelName, controllerCode) => {
  return new Promise((resolve, reject) => {
    let pathCtrl = `./${nameList.controllersFolder}/${modelName}.controller.js`
    fs.writeFile(pathCtrl, controllerCode, err => {
      if (err) {
        reject(err)
        return
      }
      utils.logCyan(`    > Controller for ${modelName} created`, true)
      resolve(utils.OK_CODE)
    })
  })
}

let generateModel = (modelName, modelCode) => {
  return new Promise((resolve, reject) => {
    let pathModel = `./${nameList.modelsFolder}/${modelName}.model.js`
    fs.writeFile(pathModel, modelCode, err => {
      if (err) {
        reject(err)
        return
      }
      utils.logGreen(`    > Model for ${modelName} created`, true)
      resolve(utils.OK_CODE)
    })
  })
}

let generateRoutes = (modelName, routesCode) => {
  return new Promise((resolve, reject) => {
    let pathRoutes = `./${nameList.routesFolder}/${modelName}.routes.js`
    fs.writeFile(pathRoutes, routesCode, err => {
      if (err) {
        reject(err)
        return
      }
      utils.logBlue(`    > Routes for ${modelName} created`, true)
      resolve(utils.OK_CODE)
    })
  })
}

let generateModelTemplate = (modelName) => {
  return renderer.renderTemplate(tmplts.modelTemplate, [{
    pattern: nameList.targetNameJoker,
    value: modelName
  }])
}

let generateControllerTemplate = (modelName) => {
  return renderer.renderTemplate(tmplts.controllerTemplate, [{
    pattern: nameList.targetNameJoker,
    value: modelName
  }])
}

let generateRoutesTemplate = (modelName) => {
  return renderer.renderTemplate(tmplts.routesTemplate, [{
    pattern: nameList.targetNameJoker,
    value: modelName
  }])
}

let makeWonderfulTrio = (modelName) => {
  return new Promise(async (resolve, reject) => {
    let errCtrl, errModel, errRoutes, ok
    // generate code for the 3 entities:
    let controllerCode = generateControllerTemplate(modelName)
    let modelCode = generateModelTemplate(modelName)
    let routesCode = generateRoutesTemplate(modelName)

    ;[errCtrl, ok] = await to(generateController(modelName, controllerCode))
    ;[errModel, ok] = await to(generateModel(modelName, modelCode))
    ;[errRoutes, ok] = await to(generateRoutes(modelName, routesCode))

    if (errCtrl || errModel || errRoutes || !ok) {
      reject(new Error('Eror in makeWonderfulTrio()'))
    } else {
      resolve(utils.OK_CODE)
    }
  })
}

let generateTrios = (entities) => {
  return entities.map((item, index) => {
    return new Promise(async (resolve, reject) => {
      let err, ok
      [err, ok] = await to(makeWonderfulTrio(entities[index]))

      if (!ok) {
        reject(err)
      } else {
        resolve(utils.OK_CODE)
      }
    })
  })
}

let makeDirectories = () => {
  fs.mkdirSync(`./${projectFolderName}`)
  console.log(`--> Created directory ${projectFolderName}`)
  process.chdir(`./${projectFolderName}`)// change to created folder
  console.log(`--> Changed working dir to ${projectFolderName}/`)

  fs.mkdirSync(`./${nameList.controllersFolder}`)
  fs.mkdirSync(`./${nameList.modelsFolder}`)
  fs.mkdirSync(`./${nameList.routesFolder}`)
  fs.mkdirSync(`./${nameList.viewsFolder}`)
  fs.mkdirSync(`./${nameList.partialsFolder}`)
}

let generateAPITester = () => {
  return new Promise((resolve, reject) => {
    fs.writeFile(`./${nameList.viewsFolder}/api-tester.hbs`,
    tmplts.apiTesterTemplate, err => {
      if (err) {
        reject(err)
        return
      }

      resolve(utils.OK_CODE)
    })
  })
}

let generateAPITesterBlock = () => {
  return new Promise((resolve, reject) => {
    // create template for item savers:
    fs.writeFile(`./${nameList.partialsFolder}/api-tester-block.hbs`,
    tmplts.apiTesterBlock, err => {
      if (err) {
        reject(err)
        return
      }

      resolve(utils.OK_CODE)
    })
  })
}

let generateAPITesterCSS = () => {
  return new Promise((resolve, reject) => {
    // create template for item savers:
    fs.writeFile(`./${nameList.partialsFolder}/api-tester-css.hbs`,
    tmplts.apiTesterCSS, err => {
      if (err) {
        reject(err)
        return
      }

      resolve(utils.OK_CODE)
    })
  })
}

let makeHTMLTemplates = async () => {
  let err, ok

  ;[err, ok] = await to(generateAPITester())
  utils.handleAwaitError(ok, err)

  ;[err, ok] = await to(generateAPITesterBlock())
  utils.handleAwaitError(ok, err)

  ;[err, ok] = await to(generateAPITesterCSS())
  utils.handleAwaitError(ok, err)
}

let generateStructure = async () => {
  let err, ok
  makeDirectories()
  makeHTMLTemplates()

  ;[err, ok] = await to(makeAppFile())
  utils.handleAwaitError(ok, err)

  ;[err, ok] = await to(makeIndexFile())
  utils.handleAwaitError(ok, err)

  ;[err, ok] = await to(makeDbFile())
  utils.handleAwaitError(ok, err)

  ;[err, ok] = await to(Promise.all(generateTrios(entitiesToCreate)))
  utils.handleAwaitError(ok, err)

  ;[err, ok] = await to(runNodeInstalls())
  utils.handleAwaitError(ok, err)
}

let listenToServer = (child) => {
  return new Promise((resolve, reject) => {
    child.stdout.on('data', data => {
      if (data == 200) {
        console.log(`Server listening in port ${port}`)
        if (argv.open || argv.o) {
          opn(`http://localhost:${port}/api-tester`)
        } else {
          console.log(`Call http://localhost:${port}/api-tester ` +
            `in your browser to interact with the API`)
          console.log(`(use --open to launch it automatically)`)
        }

        resolve(utils.OK_CODE)
      }
    })
    child.stderr.on('data', data => console.log(data))
    child.on('close', code => {
      console.log(`Exited with code ${code}`)
      reject(code)
    })
  })
}

let runServer = () => {
  return new Promise(async (resolve, reject) => {
    let child = exec(`node index`)
    let err, ok

    console.log('-'.repeat(utils.dottedLineLength))
    console.log('Starting server...')

    [err, ok] = await to(listenToServer(child))

    if (!ok) {
      reject(err)
    } else {
      resolve(utils.OK_CODE)
    }
  })
}

let runNodeInstalls = () => {
  return new Promise(async (resolve, reject) => {
    let err, ok
    // setup and dependencies:
    [err, ok] = await to(nodeSetup.init(projectFolderName))
    if (!ok) { reject(err) } else { resolve(utils.OK_CODE) }

    if (argv.run === false || argv.n) {
      console.log(`Build OK, to start the server run 'node index' inside ` +
      `${projectFolderName}/`)
      console.log(`Once the server is running, ` +
      `use http://localhost:${port}/api-tester to test your API`)
    } else {
      [err, ok] = await to(runServer())// last step

      if (!ok) { reject(err) } else { resolve(utils.OK_CODE) }
    }
  })
}

if (projectFolderName) {
  if (fs.existsSync(projectFolderName)) {
    utils.logYellow(`WARN: Folder ${projectFolderName} ` +
    `already exists, please use another name`, true)
  } else {
    generateStructure()
  }
} else {
  console.log('men v0.1.6')
  console.log('Usage: men <yourProjectFolder>')
  console.log(`men --help to see more options`)
}
